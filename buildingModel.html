<!DOCTYPE html>
<html>
<head>
  <title>DisneyLand</title>
     <link rel="icon" href="buildingTexture/MIU-Logo-20th.png">
     <script src="buildingTexture/three.min.js"></script>
     <script src="buildingTexture/functions.js"></script>
     <script src="buildingTexture/OrbitControls.js"></script>
     <script type="text/javascript" src="buildingTexture/TrackballControls.js"></script>
     <link href="https://fonts.googleapis.com/css?family=Crafty+Girls" rel="stylesheet">
  <style>
  body{
    overflow: hidden;
    margin:0;
  }
    h3{
      display: block;
      font-size: 50px;
      line-height: 28px;
      color: #082236;
      text-decoration: none;
	  z-index: 10;
	  position: absolute;
      margin: 50px 5px;
      position: absolute;
      text-align: center;
      opacity: 0.5;
      width:100%;
      font-family: 'Crafty Girls', cursive;
	  }
  </style>
</head>
<body>
  <div>

  </div>

  <script>
    var scene, camera, renderer, width, height, controls
    var color = { background: 0xA9D5F6 }
    width = window.innerWidth
    height = window.innerHeight
	
    scene = new THREE.Scene()
    camera = new THREE.PerspectiveCamera(45, width / height, 1, 8000);
    camera.position.x = 0;
    camera.position.y = 590;
	camera.position.z = 1500;
	scene.add(camera)
	
	renderer = new THREE.WebGLRenderer()
    renderer.setSize(width, height)
    renderer.setClearColor(color.background)
    renderer.shadowMap.enabled = true
	renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    document.body.appendChild(renderer.domElement)


    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.maxPolarAngle = Math.PI / 2.5;

	addTrees()
    Light()
    building()
	game()
	castle()
    
    onWindowResize()
    
    function building () {
      
      addBuilding()

      function addBuilding () {
        var building = createBuilding()
        building.position.z = 145
		building.scale.set(1.2,1.2,1.2)
        scene.add(building)  
      }
	  

      function createBuilding () {
        var building = new THREE.Object3D()

		//Base
        var baseGeometry = new THREE.BoxBufferGeometry(100, 3, 100)
        var base = utils.makeMesh('lambert', baseGeometry, 0x838383)
        base.position.y = 1
        building.add(base)

		//Main Building Shape
        var MainCoords = [
          [-60, -30], [-60, 20], [60, 20], [60, 0], [60, -30], [60, -30]
        ]
		//Main Building Creation
        var MainShape = utils.makeShape(MainCoords)
        var Geometry = utils.makeExtrudeGeometry(MainShape,100)
        var Material = new THREE.MeshPhongMaterial({color: 0x796e8c,
        opacity: 0.9,
        transparent: true})
        var Main = new THREE.Mesh(Geometry, Material)
        Main.castShadow = true
        Main.receiveShadow = true
        building.add(Main)

		//Main Roof Base
        var MainTop = MainShape
        var Geometry = utils.makeExtrudeGeometry(MainTop, 1)
        var Material = utils.makeMesh('lambert', Geometry, 0x0792a5)
        Material.position.y = 100
        building.add(Material)
        
        //Main Building Plat
        var Geometry = new THREE.BoxBufferGeometry(155,3,90)
        var Plat = utils.makeMesh('lambert', Geometry, 0x0792a5)
        Plat.position.set(1,18,25)
        building.add(Plat)

		//Vertical Plat
        var Geometry = new THREE.BoxBufferGeometry(100, 15, 3)
        var Vertical = utils.makeMesh('phong', Geometry, 0x0792a5)
        Vertical.receiveShadow = false
        Vertical.position.set(-26.5, 24, 68.5)
        building.add(Vertical)

		//Vertical White Plat
        var Geometry = new THREE.BoxBufferGeometry(100, 3, 3)
        var Material = utils.makeMesh('phong', Geometry, 0xffffff)
        Material.position.set(-26.5, 33, 68.5)
        building.add(Material)

		//First Front Pillar
        var Geometry = new THREE.CylinderGeometry(2, 2, 15, 32)
        var Pillar = utils.makeMesh('lambert', Geometry, 0xffffff)
        Pillar.position.set(-40, 10, 55)
        building.add(Pillar)

		//Second Front Pillar
        var Pillar2 = Pillar.clone()
        Pillar2.position.set(40, 10, 55)
        building.add(Pillar2)

		//Long 8 Pillars
        var Verticles = new THREE.Object3D()
        var Geometry = new THREE.BoxBufferGeometry(4, 102, 4)
        var Mesh = utils.makeMesh('phong', Geometry, 0xffffff)
        
		var Verticle1 = Mesh.clone()
        Verticle1.position.set(-60, 52, 30)
        Verticles.add(Verticle1)
		
        var Verticle2 = Mesh.clone()
        Verticle2.position.set(-60, 52, -20)
        Verticles.add(Verticle2)

		var Verticle3 = Mesh.clone()
        Verticle3.position.set(60, 52, -18)
        Verticles.add(Verticle3)
		
		var Verticle4 = Mesh.clone()
        Verticle4.position.set(60, 52, 30)
        Verticles.add(Verticle4)
		
		var Verticle5 = Mesh.clone()
        Verticle5.position.set(80, 52, -21)
        Verticles.add(Verticle5)
		
		var Verticle6 = Mesh.clone()
        Verticle6.position.set(-80, 52, -59.5)
        Verticles.add(Verticle6)
		
		var Verticle7 = Mesh.clone()
        Verticle7.position.set(80, 52, -59.5)
        Verticles.add(Verticle7)
		
		var Verticle8 = Mesh.clone()
        Verticle8.position.set(-80, 52, -18)
        Verticles.add(Verticle8)
		building.add(Verticles)
		
        var Coords = [
          [-80, 20], [-80, 60], [80, 60], [80, 20], [-80, 20]
        ]
        
        var Main = utils.makeShape(Coords)
		var Geometry = utils.makeExtrudeGeometry(Main, 90)        
		var backMain = utils.makeMesh('lambert', Geometry, 0xf2e21b)
        building.add(backMain)

		//Back Main Roof Base
        var Top1 = Main
        var Geometry = utils.makeExtrudeGeometry(Top1, 1)
        var Mesh = utils.makeMesh('lambert', Geometry, 0xf2e21b)
		
        Mesh.position.x = 0
		Mesh.position.y = 100
        Mesh.position.z = 0
       
        building.add(Mesh)
		
		var Top2 = Main
        var frontTopGeometry = utils.makeExtrudeGeometry(Top2, 1)
        var Mesh = utils.makeMesh('lambert', Geometry, 0xffffff)
        Mesh.position.x = 0
		Mesh.position.y = 90
        Mesh.position.z = 0
       
        building.add(Mesh)

		//Sideways
		var Geometry = new THREE.BoxBufferGeometry(50, 3, 168)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = 0
		Mesh.position.y = 1
        Mesh.position.z = 80
        Mesh.rotation.y = 1 * Math.PI
        building.add(Mesh)
		
		var Geometry = new THREE.BoxBufferGeometry(20, 3, 310)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = -150
		Mesh.position.y = 1
        Mesh.position.z = 5
        Mesh.rotation.y = 1 * Math.PI
        building.add(Mesh)
	
	    var Geometry = new THREE.BoxBufferGeometry(20, 3, 310)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = -5
		Mesh.position.y = 1
        Mesh.position.z = -145
        Mesh.rotation.y = 1.5 * Math.PI
        building.add(Mesh)
		
		var Geometry = new THREE.BoxBufferGeometry(20, 3, 320)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = 150
		Mesh.position.y = 1
        Mesh.position.z = 5
        Mesh.rotation.y = 1 * Math.PI
        building.add(Mesh)
		
		var Geometry = new THREE.BoxBufferGeometry(20, 3, 310)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = -5
		Mesh.position.y = 1
        Mesh.position.z = 155
        Mesh.rotation.y = 1.5 * Math.PI
        building.add(Mesh)
		
		
	    //Side Window
        var Geometry = new THREE.PlaneGeometry(30,70,1,1)
        var Material = new THREE.MeshPhongMaterial({color: 0x796e8c})
		
        var Window = new THREE.Mesh(Geometry, Material)
        Window.position.set(81, 46, -40.5)
        Window.rotation.y = 0.5 * Math.PI
        building.add(Window)
		
		//Side Window 2
        var Geometry = new THREE.PlaneGeometry(32,76,1,1)
        var Material = new THREE.MeshPhongMaterial({color: 0x796e8c})

        var Window2 = new THREE.Mesh(Geometry, Material)
        Window2.position.set(-81, 46, -40)
        Window2.rotation.y = 1.5 * Math.PI
        building.add(Window2)
		
	
        var Back = addWindow()
        Back.scale.set(1.5,1.5,1)
        Back.rotation.y = Math.PI
        Back.position.set(40, 68, -61)
        for (var i = 0; i < 2; i++) {
          for (var j = 0; j < 2; j++) {
            var window = Back.clone()
            window.position.x -= i * 70
            window.position.y -= j * 45
            building.add(window)
          }
        }
        return building
      }

      function addWindow () {
        var window = new THREE.Object3D()
        var Geometry = new THREE.PlaneGeometry(20, 20)
        var glass = utils.makeMesh2('phong', Geometry, 0x796e8c)
        window.add(glass)

        var BorderGeometry = new THREE.BoxBufferGeometry(20.5,0.5,0.5)
        var Border = utils.makeMesh('phong', BorderGeometry, 0xffffff)

        var Top = Border.clone()
        Top.position.y = 10
        window.add(Top)

        var Bottom = Border.clone()
        Bottom.position.y = -10
        window.add(Bottom)

        var Left = Border.clone()
        Left.rotation.z = 0.5 * Math.PI
        Left.position.x = -10
        window.add(Left)

        var Right = Left.clone()
        Right.position.x = 10
        window.add(Right)

        return window
      }
    }
    
    function Light() {
      
	     var direction = 1200;
        var directional = new THREE.DirectionalLight( 0xffffff , 1.1);
        directional.position.set( 300, 1000, 500 );
        directional.target.position.set( 0, 0, 0 );
        directional.castShadow = true;
        directional.shadow.camera = new THREE.OrthographicCamera( -direction, direction, direction, -direction,  500, 1600 );
        directional.shadow.mapSize.width = directional.shadow.mapSize.height = 1024;
        scene.add(directional)
        var light = new THREE.AmbientLight( 0xffffff, 0.4 )
        scene.add(light)

    }
	
	function addTrees () {
        var Position = [ [-130, 150],[-130,  0],[130,  0],[ 130,  150], [130, 300],  [50, 300], [-50, 300],  [-130, 300] ]
        Position.forEach(function (t) {
          var x = t[0], y = 1, z = t[1]
          var tree = addTree(x, y, z)
          scene.add(tree)
        })
    }
	function addTree (x, y, z) {	
        var tree = new THREE.Object3D()
        var TrunkGeometry = new THREE.BoxBufferGeometry(3,10,2)
        var Trunk = utils.makeMesh('lambert', TrunkGeometry, 0x8a613a)
        Trunk.position.y = 5
        tree.add(Trunk)
        var Geometry = new THREE.SphereGeometry(12, 25,10)
        var Leafs = utils.makeMesh('lambert', Geometry, 0x9c9e5d)
        Leafs.position.y = 20
        tree.add( Leafs)
        tree.position.set(x, y, z)
        return tree
      }

function game () {

      addgame()

      function addgame() {
        var building = creategame()
        building.position.set(-520,0,-200);
		building.scale.set(0.4,0.4,0.4)
		building.rotation.y = 0.5 * Math.PI
        scene.add(building)  
      }
	  

      function creategame () {
        var building = new THREE.Object3D()

		//Base
		var baseGeometry = new THREE.BoxBufferGeometry(400, 10, 200)
        var base = utils.makeMesh('lambert', baseGeometry, 0xc86432)
        base.position.y = 6
		base.position.x = 0
		base.position.z = 350
        building.add(base)
		
		var baseGeometry = new THREE.BoxBufferGeometry(380, 50, 180)
        var base = utils.makeMesh('lambert', baseGeometry, 0x5e090c)
        base.position.y = 35
		base.position.x = 0
		base.position.z = 352
        building.add(base)
		
		var baseGeometry = new THREE.BoxBufferGeometry(390, 10, 190)
        var base = utils.makeMesh('lambert', baseGeometry, 0x3f3a36)
        base.position.y = 65
		base.position.x = 0
		base.position.z = 350
        building.add(base)
		
	
		var stairs = new THREE.Object3D()
		var baseGeometry = new THREE.BoxBufferGeometry(50, 63, 20)
        var base = utils.makeMesh('lambert', baseGeometry, 0x263465)
        base.position.y = 28
		base.position.x = -110
		base.position.z = 450
        stairs.add(base)

		var baseGeometry = new THREE.BoxBufferGeometry(50, 43, 20)
        var base = utils.makeMesh('lambert', baseGeometry, 0x263465)
        base.position.y = 20
		base.position.x = -110
		base.position.z = 470
        stairs.add(base)
		
		var baseGeometry = new THREE.BoxBufferGeometry(50, 33, 20)
        var base = utils.makeMesh('lambert', baseGeometry, 0x263465)
        base.position.y = 13
		base.position.x = -110
		base.position.z = 488
        stairs.add(base)
		building.add(stairs)
		
		var stairs2 = new THREE.Object3D 
		var baseGeometry = new THREE.BoxBufferGeometry(50, 63, 20)
        var base = utils.makeMesh('lambert', baseGeometry, 0x263465)
        base.position.y = 28
		base.position.x = 110
		base.position.z = 450
        stairs2.add(base)

		var baseGeometry = new THREE.BoxBufferGeometry(50, 43, 20)
        var base = utils.makeMesh('lambert', baseGeometry, 0x263465)
        base.position.y = 20
		base.position.x = 110
		base.position.z = 470
        stairs2.add(base)
		
		var baseGeometry = new THREE.BoxBufferGeometry(50, 33, 20)
        var base = utils.makeMesh('lambert', baseGeometry, 0x263465)
        base.position.y = 13
		base.position.x = 110
		base.position.z = 488
        stairs2.add(base)
		building.add(stairs2)
		
		var allfence = new THREE.Object3D()
		//1
		var shelfGeometry = new THREE.Geometry()
        var fenceGeometry = new THREE.BoxGeometry(2, 2, 40)
		var lineGeometry = new THREE.BoxGeometry(2, 2, 90)
        // for z-axis
        for (var i = 0; i < 12; i++) {
          var geometry = fenceGeometry.clone()
          geometry.translate(i * 15, 0, 0)
          shelfGeometry.merge(geometry)
        }
        // for x-axis
        for (var i = 0; i < 2; i++) {
          var geometry = lineGeometry.clone()
          geometry.rotateY(0.5 * Math.PI)
          geometry.scale(2,1,1)
          geometry.translate(82, 0, -15 + i*30)
          shelfGeometry.merge(geometry)
        }
        shelfGeometry = new THREE.BufferGeometry().fromGeometry(shelfGeometry)
        var Shelf = utils.makeMesh('phong',shelfGeometry, 0xf09b4a)
        Shelf.position.set(-83, 90, 440)
		Shelf.rotation.x = 0.5 * Math.PI
        allfence.add(Shelf)
		//2
		var shelfGeometry = new THREE.Geometry()
        var fenceGeometry = new THREE.BoxGeometry(2, 2, 40)
		var lineGeometry = new THREE.BoxGeometry(2, 2, 190)
        // for z-axis
        for (var i = 0; i < 26; i++) {
          var geometry = fenceGeometry.clone()
          geometry.translate(i * 15, 0, 0)
          shelfGeometry.merge(geometry)
        }
        // for x-axis
        for (var i = 0; i < 2; i++) {
          var geometry = lineGeometry.clone()
          geometry.rotateY(0.5 * Math.PI)
          geometry.scale(2,1,1)
          geometry.translate(190, 0, -15 + i*30)
          shelfGeometry.merge(geometry)
        }
        shelfGeometry = new THREE.BufferGeometry().fromGeometry(shelfGeometry)
        var Shelf = utils.makeMesh('phong',shelfGeometry, 0xf09b4a)
        Shelf.position.set(-189, 90, 265)
		Shelf.rotation.x = 0.5 * Math.PI
        allfence.add(Shelf)
		
		//3
		var shelfGeometry = new THREE.Geometry()
        var fenceGeometry = new THREE.BoxGeometry(2, 2, 40)
		var lineGeometry = new THREE.BoxGeometry(2, 2, 90)
        // for z-axis
        for (var i = 0; i < 12; i++) {
          var geometry = fenceGeometry.clone()
          geometry.translate(i * 15, 0, 0)
          shelfGeometry.merge(geometry)
        }
        // for x-axis
        for (var i = 0; i < 2; i++) {
          var geometry = lineGeometry.clone()
          geometry.rotateY(0.5 * Math.PI)
          geometry.scale(2,1,1)
          geometry.translate(82, 0, -15 + i*30)
          shelfGeometry.merge(geometry)
        }
        shelfGeometry = new THREE.BufferGeometry().fromGeometry(shelfGeometry)
        var Shelf = utils.makeMesh('phong',shelfGeometry, 0xf09b4a)
        Shelf.position.set(-190, 90, 270)
		Shelf.rotation.x = 0.5 * Math.PI
		Shelf.rotation.z = 0.5 * Math.PI
        allfence.add(Shelf)
		
		//4
		var shelfGeometry = new THREE.Geometry()
        var fenceGeometry = new THREE.BoxGeometry(2, 2, 40)
		var lineGeometry = new THREE.BoxGeometry(2, 2, 90)
        // for z-axis
        for (var i = 0; i < 12; i++) {
          var geometry = fenceGeometry.clone()
          geometry.translate(i * 15, 0, 0)
          shelfGeometry.merge(geometry)
        }
        // for x-axis
        for (var i = 0; i < 2; i++) {
          var geometry = lineGeometry.clone()
          geometry.rotateY(0.5 * Math.PI)
          geometry.scale(2,1,1)
          geometry.translate(82, 0, -15 + i*30)
          shelfGeometry.merge(geometry)
        }
        shelfGeometry = new THREE.BufferGeometry().fromGeometry(shelfGeometry)
        var Shelf = utils.makeMesh('phong',shelfGeometry, 0xf09b4a)
        Shelf.position.set(190, 90, 270)
		Shelf.rotation.x = 0.5 * Math.PI
		Shelf.rotation.z = 0.5 * Math.PI
        allfence.add(Shelf)
		building.add(allfence)
		
		var baseGeometry = new THREE.BoxBufferGeometry(150, 20, 90)
        var base = utils.makeMesh('lambert', baseGeometry, 0xADC1BB)
        base.position.y = 74
		base.position.x = 0
		base.position.z = 320
        building.add(base)
		
		var baseGeometry = new THREE.BoxBufferGeometry(130, 10, 75)
        var base = utils.makeMesh('lambert', baseGeometry, 0xADC1BB)
        base.position.y = 88
		base.position.x = 0
		base.position.z = 320
        building.add(base)
		
		var baseGeometry = new THREE.BoxBufferGeometry(50, 300, 20)
        var base = utils.makeMesh('lambert', baseGeometry, 0xBF0909)
        base.position.y = 230
		base.position.x = 0
		base.position.z = 320
        building.add(base)
		
		var baseGeometry = new THREE.BoxBufferGeometry(15, 280, 2)
        var base = utils.makeMesh('lambert', baseGeometry, 0xF3E356)
        base.position.y = 190
		base.position.x = 0
		base.position.z = 330
        building.add(base)
		
		var circle = new THREE.Object3D()
		circle.castShadow = true;
		circle.receiveShadow = true;

		var geometry = new THREE.CylinderGeometry(20, 30, 10, 9, 2);
        var cube = utils.makeMesh('lambert', geometry, 0xADC1BB)
		cube.position.y = 360
		cube.position.x = 0
		cube.position.z = 340
		cube.rotation.x = 0.5 * Math.PI
		cube.castShadow = true;
        cube.receiveShadow = true;
        circle.add( cube );
	
        building.add( circle )

        return building
      }

     }	

	
	var Balloons = function(){
			 		THREE.Group.apply(this, arguments);
						//ticket

						    //Red
							var geometry = new THREE.SphereBufferGeometry( 50, 10, 32 );
                            var material = new THREE.MeshLambertMaterial({color: 0xF32905});
                            var sphere = new THREE.Mesh( geometry, material );
							sphere.position.set(-700,200,-350);
							sphere.castShadow = true;
                            sphere.receiveShadow = true;
                            this.add( sphere ); 

							//Blue
							var geometry = new THREE.SphereGeometry( 50, 10, 32 );
                            var material = new THREE.MeshLambertMaterial( {color: 0x0522F3} );
                            var sphere = new THREE.Mesh( geometry, material );
							sphere.position.set(-750,150,-440);
							sphere.castShadow = true;
                            sphere.receiveShadow = true;
                            this.add( sphere ); 

							//Green
							var geometry = new THREE.SphereGeometry( 50, 10, 32 );
                            var material = new THREE.MeshLambertMaterial( {color: 0x22F305} );
                            var sphere = new THREE.Mesh( geometry, material );
							sphere.position.set(-800,200,-370);
							sphere.castShadow = true;
                            sphere.receiveShadow = true;
                            this.add( sphere );
							
							//Yellow
							var geometry = new THREE.SphereGeometry( 50, 10, 32 );
                            var material = new THREE.MeshLambertMaterial( {color: 0xF3F305} );
                            var sphere = new THREE.Mesh( geometry, material );
							sphere.position.set(-750,250,-400);
							sphere.castShadow = true;
                            sphere.receiveShadow = true;
                            this.add( sphere );
							
							var material = new THREE.LineBasicMaterial({
	                        color: 0x000000
                            });

                            var geometry = new THREE.Geometry();
                            geometry.vertices.push(
	                        new THREE.Vector3(-700,200,-350),
	                        new THREE.Vector3( -750, 0, -350 )
                            );

                            var line = new THREE.Line( geometry, material );
							line.castShadow = true;
                            line.receiveShadow = true;
                            this.add( line );
							
							var material = new THREE.LineBasicMaterial({
	                        color: 0x000000
                            });

                            var geometry = new THREE.Geometry();
                            geometry.vertices.push(
	                        new THREE.Vector3(-750,150,-440),
	                        new THREE.Vector3( -750, 0, -350 )
                            );

                            var line = new THREE.Line( geometry, material );
							line.castShadow = true;
                            line.receiveShadow = true;
                            this.add( line );
							
							var material = new THREE.LineBasicMaterial({
	                        color: 0x000000
                            });

                            var geometry = new THREE.Geometry();
                            geometry.vertices.push(
	                        new THREE.Vector3(-800,200,-370 ),
	                        new THREE.Vector3( -750, 0, -350 )
                            );

                            var line = new THREE.Line( geometry, material );
							line.castShadow = true;
                            line.receiveShadow = true;
                            this.add( line );
							
							var material = new THREE.LineBasicMaterial({
	                        color: 0x000000
                            });

                            var geometry = new THREE.Geometry();
                            geometry.vertices.push(
	                        new THREE.Vector3(-750,250,-400 ),
	                        new THREE.Vector3( -750, 0, -350 )
                            );

                            var line = new THREE.Line( geometry, material );
							line.castShadow = true;
                            line.receiveShadow = true;
                            this.add( line );
							
							//Group 2 

							//Red
							var geometry = new THREE.SphereBufferGeometry( 50, 10, 32 );
                            var material = new THREE.MeshLambertMaterial({color: 0xF32905});
                            var sphere = new THREE.Mesh( geometry, material );
							sphere.position.set(700,200,1150);
							sphere.castShadow = true;
                            sphere.receiveShadow = true;
                            this.add( sphere ); 

							//Blue
							var geometry = new THREE.SphereGeometry( 50, 10, 32 );
                            var material = new THREE.MeshLambertMaterial( {color: 0x0522F3} );
                            var sphere = new THREE.Mesh( geometry, material );
							sphere.position.set(750,150,1140);
							sphere.castShadow = true;
                            sphere.receiveShadow = true;
                            this.add( sphere ); 

							//Green
							var geometry = new THREE.SphereGeometry( 50, 10, 32 );
                            var material = new THREE.MeshLambertMaterial( {color: 0x22F305} );
                            var sphere = new THREE.Mesh( geometry, material );
							sphere.position.set(800,200,1170);
							sphere.castShadow = true;
                            sphere.receiveShadow = true;
                            this.add( sphere );
							
							//Yellow
							var geometry = new THREE.SphereGeometry( 50, 10, 32 );
                            var material = new THREE.MeshLambertMaterial( {color: 0xF3F305} );
                            var sphere = new THREE.Mesh( geometry, material );
							sphere.position.set(750,250,1100);
							sphere.castShadow = true;
                            sphere.receiveShadow = true;
                            this.add( sphere );
							
							var material = new THREE.LineBasicMaterial({
	                        color: 0x000000
                            });

                            var geometry = new THREE.Geometry();
                            geometry.vertices.push(
	                        new THREE.Vector3(700,200,1150),
	                        new THREE.Vector3(750, 0, 1200 )
                            );

                            var line = new THREE.Line( geometry, material );
							line.castShadow = true;
                            line.receiveShadow = true;
                            this.add( line );
							
							var material = new THREE.LineBasicMaterial({
	                        color: 0x000000
                            });

                            var geometry = new THREE.Geometry();
                            geometry.vertices.push(
	                        new THREE.Vector3(750,150,1140),
	                        new THREE.Vector3(750, 0, 1200)
                            );

                            var line = new THREE.Line( geometry, material );
							line.castShadow = true;
                            line.receiveShadow = true;
                            this.add( line );
							
							var material = new THREE.LineBasicMaterial({
	                        color: 0x000000
                            });

                            var geometry = new THREE.Geometry();
                            geometry.vertices.push(
	                        new THREE.Vector3(800,200,1170 ),
	                        new THREE.Vector3(750, 0, 1200)
                            );

                            var line = new THREE.Line( geometry, material );
							line.castShadow = true;
                            line.receiveShadow = true;
                            this.add( line );
							
							var material = new THREE.LineBasicMaterial({
	                        color: 0x000000
                            });

                            var geometry = new THREE.Geometry();
                            geometry.vertices.push(
	                        new THREE.Vector3(750,250,1100),
	                        new THREE.Vector3(750, 0, 1200)
                            );

                            var line = new THREE.Line( geometry, material );
							line.castShadow = true;
                            line.receiveShadow = true;
                            this.add( line );
						
				}
				Balloons.prototype = Object.create(THREE.Group.prototype);
				Balloons.prototype.constructor = Balloons;

				var balloon = new Balloons();
				balloon.scale.set(0.3,0.3,0.3);
				balloon.castShadow = true;
                balloon.receiveShadow = true;
				scene.add(balloon);  
	  
	  
	var Shops = function(){
			 		THREE.Group.apply(this, arguments);
						//ticket

							    var ticketSides = [
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/redtickets.jpg'), side :THREE.DoubleSide}), //right
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/redtickets.jpg'), side :THREE.DoubleSide}), //left
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/redtickets.jpg'), side :THREE.DoubleSide}), //top
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/redtickets.jpg'), side :THREE.DoubleSide}), //bottom
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/tickets.jpg'), side :THREE.DoubleSide}),
			                        //front
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/redtickets.jpg'), side :THREE.DoubleSide})
			                        //back
			                                
			                    ];

								var geometry = new THREE.BoxBufferGeometry(180,210,120);
								var material = new THREE.MeshFaceMaterial(ticketSides);
								var mesh = new THREE.Mesh(geometry,material);
								mesh.position.set(900,100,-600);
								mesh.rotation.y = 1.5 * Math.PI
								mesh.castShadow = true;
                                mesh.receiveShadow = true;
								this.add(mesh);

								

						//burger

								   var burgerSides = [
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/orgstripes.png'), side :THREE.DoubleSide}), //right
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/orgstripes.png'), side :THREE.DoubleSide}), //left
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/orgstripes.png'), side :THREE.DoubleSide}), //top
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/orgstripes.png'), side :THREE.DoubleSide}), //bottom
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/burguer.png'), side :THREE.DoubleSide}),
			                        //front
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/orgstripes.png'), side :THREE.DoubleSide})
			                        //back
			                                
			                    	];

									var geometry = new THREE.BoxBufferGeometry(180,210,120);
									var material = new THREE.MeshFaceMaterial(burgerSides);
									var mesh = new THREE.Mesh(geometry,material);
									mesh.position.set(900,100,-400);
									mesh.rotation.y = 1.5 * Math.PI
									mesh.castShadow = true;
                                    mesh.receiveShadow = true;
									this.add(mesh);

									
						//ticket tani

								var geometry = new THREE.BoxBufferGeometry(180,210,120);
								var material = new THREE.MeshFaceMaterial(ticketSides);
								var mesh = new THREE.Mesh(geometry,material);
								mesh.position.set(-900,100,1000);
								mesh.rotation.y = 0.5 * Math.PI
								mesh.castShadow = true;
                                mesh.receiveShadow = true;
								this.add(mesh);
								

						//burger tani

									var geometry = new THREE.BoxBufferGeometry(180,210,120);
									var material = new THREE.MeshFaceMaterial(burgerSides);
									var mesh = new THREE.Mesh(geometry,material);
									mesh.position.set(-900,100,1200);
									mesh.rotation.y = 0.5 * Math.PI
									mesh.castShadow = true;
                                    mesh.receiveShadow = true;
									this.add(mesh);
									
									//candyshop

									var candySides = [
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/pinkStripes.jpg'), side :THREE.DoubleSide}), //right
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/pinkStripes.jpg'), side :THREE.DoubleSide}), //left
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/pinkStripes.jpg'), side :THREE.DoubleSide}), //top
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/pinkStripes.jpg'), side :THREE.DoubleSide}), //bottom
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/candy1.png'), side :THREE.DoubleSide}),
			                        //front
			                        new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('textures/pinkStripes.jpg'), side :THREE.DoubleSide})
			                        //back
			                                
			                    	];

									var geometry = new THREE.BoxBufferGeometry(180,210,120);
									var material = new THREE.MeshFaceMaterial(candySides);
									var mesh = new THREE.Mesh(geometry,material);
									mesh.position.set(900,100,1000);
									mesh.rotation.y = 1.5 * Math.PI
									mesh.castShadow = true;
                                    mesh.receiveShadow = true;
									this.add(mesh);
									

                                    //burger tani.
									var geometry = new THREE.BoxBufferGeometry(180,210,120);
									var material = new THREE.MeshFaceMaterial(burgerSides);
									var mesh = new THREE.Mesh(geometry,material);
									mesh.position.set(900,100,1200);
									mesh.rotation.y = 1.5 * Math.PI
									mesh.castShadow = true;
                                    mesh.receiveShadow = true;
									this.add(mesh);

				}
				Shops.prototype = Object.create(THREE.Group.prototype);
				Shops.prototype.constructor = Shops;

				var shop = new Shops();
				shop.scale.set(0.5,0.5,0.5);
				shop.castShadow = true;
                shop.receiveShadow = true;
				scene.add(shop);
	  
	  
	function castle(){
	
	    addCastle ()
	
	    function addCastle () {
        var castle = createCastle()
        castle.position.z = -570
		castle.position.y = 50
        scene.add(castle)  
        }
	

	    function createCastle(){
	
	        var castle = new THREE.Object3D()
	        var texture = new THREE.TextureLoader().load( "textures/wall2.jpg" );
			var texture2 = new THREE.TextureLoader().load("textures/golden2.jpg");
			var texture3 = new THREE.TextureLoader().load("textures/stones.jpg");

			texture3.wrapS = texture3.wrapT = THREE.RepeatWrapping;
			texture3.repeat.set(1,1);

			//largest base
			var base = new THREE.BoxGeometry(300,100,300);
			var material = new THREE.MeshBasicMaterial({map:texture3});
			var baseMesh = new THREE.Mesh(base, material);
			castle.add(baseMesh);

			/*LEFT SIDE*/

			/*FRONT LEFT*/

			//left side cylinder
			var left1 = new THREE.CylinderGeometry( 30, 45, 130, 32 );
			var material2 = new THREE.MeshBasicMaterial( {map: texture} );
			var leftSide1 = new THREE.Mesh( left1, material2 );
			leftSide1.position.x = -190;
			leftSide1.position.y += 15;
			leftSide1.position.z = 100;
			castle.add( leftSide1 );

			//left gold top torus
			var geometry2 = new THREE.TorusGeometry(30,40,50,100);
			var material3 = new THREE.MeshBasicMaterial({map:texture2});
			var round = new THREE.Mesh(geometry2,material3);
			round.position.x = -190;
			round.position.y += 120;
			round.position.z = 90;
			round.rotateX(Math.PI/2);
			castle.add(round);

			// top cone
			var shape2 = new THREE.ConeGeometry( 20, 30, 40 );
			material3 = new THREE.MeshBasicMaterial({map:texture2})
			var cone2 = new THREE.Mesh( shape2, material3 );
			cone2.position.x = -190;
			cone2.position.y += 175;
			cone2.position.z = 95;
			castle.add( cone2 );


			/*BACK LEFT*/

			//left side cylinder
			var left2 = new THREE.CylinderGeometry( 60, 100, 300, 32 );
			material2 = new THREE.MeshBasicMaterial( {map: texture} );
			var leftSide2 = new THREE.Mesh( left2, material2 );
			leftSide2.position.x = -250;
			leftSide2.position.y += 100;
			leftSide2.position.z = -70;
			castle.add( leftSide2 );

			//left gold top
			var geometry3 = new THREE.TorusGeometry(50,60,70,100);
			material3 = new THREE.MeshBasicMaterial({map:texture2});
			var round2 = new THREE.Mesh(geometry3,material3);
			round2.position.x = -250;
			round2.position.y += 250;
			round2.position.z = -70;
			round2.rotateX(Math.PI/2);
			castle.add(round2);

			// top cone
			var shape3 = new THREE.ConeGeometry( 30, 40, 60 );
			material3 = new THREE.MeshBasicMaterial({map:texture2})
			var cone3 = new THREE.Mesh( shape3, material3 );
			cone3.position.x = -250;
			cone3.position.y += 320;
			cone3.position.z = -70;
			castle.add( cone3 );



									/*RIGHT SIDE*/

			/*FRONT RIGHT*/

			//right side
			var right1 = new THREE.CylinderGeometry( 30, 45, 130, 32 );
			material2 = new THREE.MeshBasicMaterial( {map: texture} );
			var rightSide1 = new THREE.Mesh( right1, material2 );
			rightSide1.position.x += 190;
			rightSide1.position.y += 15;
			rightSide1.position.z = 100;
			castle.add( rightSide1 );

			//right gold top
			var geometry3 = new THREE.TorusGeometry(30,40,50,100);
			material3 = new THREE.MeshBasicMaterial({map:texture2});
			var round2 = new THREE.Mesh(geometry3,material3);
			round2.position.y += 120;
			round2.position.x = 190;
			round2.position.z = 90;
			round2.rotateX(Math.PI/2);
			castle.add(round2);

			// top cone
			var shape4 = new THREE.ConeGeometry( 20, 30, 40 );
			material3 = new THREE.MeshBasicMaterial({map:texture2})
			var cone4 = new THREE.Mesh( shape4, material3 );
			cone4.position.x = 190;
			cone4.position.y += 175;
			cone4.position.z = 95;
			castle.add( cone4 );



			/*BACK RIGHT*/

			//right side cylinder
			var right2 = new THREE.CylinderGeometry( 60, 100, 300, 32 );
			material2 = new THREE.MeshBasicMaterial( {map: texture} );
			var rightSide2 = new THREE.Mesh( right2, material2 );
			rightSide2.position.x = 250;
			rightSide2.position.y += 100;
			rightSide2.position.z = -70;
			castle.add( rightSide2 );

			//right gold top torus
			var geometry4 = new THREE.TorusGeometry(50,60,70,100);
			material3 = new THREE.MeshBasicMaterial({map:texture2});
			var round4 = new THREE.Mesh(geometry4,material3);
			round4.position.x = 250;
			round4.position.y += 250;
			round4.position.z = -70;
			round4.rotateX(Math.PI/2);
			castle.add(round4);

			// top cone
			var shape5 = new THREE.ConeGeometry( 30, 40, 60 );
			material3 = new THREE.MeshBasicMaterial({map:texture2})
			var cone5 = new THREE.Mesh( shape5, material3 );
			cone5.position.x = 250;
			cone5.position.y += 320;
			cone5.position.z = -70;
			castle.add( cone5 );



										/*MIDDLE*/

			//middle cylinder
			var middle = new THREE.CylinderGeometry( 100, 140, 400, 32 );
			material2 = new THREE.MeshBasicMaterial( {map: texture} );
			var middleMesh = new THREE.Mesh( middle, material2 );
			//middleMesh.position.x = 250;
			middleMesh.position.y += 180;
			//middleMesh.position.z = -70;
			castle.add( middleMesh );

			//door
			var arch = new THREE.CircleBufferGeometry( 70, 100, 0, Math.PI);
			var newMaterial = new THREE.MeshBasicMaterial( { color: 0x707070, side: THREE.DoubleSide } );
			var archMesh = new THREE.Mesh( arch, newMaterial );
			archMesh.position.y = 45;
			archMesh.position.z = 140;
			castle.add( archMesh );

			//middle gold top torus
			var bigTop = new THREE.TorusGeometry(80,90,100,100);
			material3 = new THREE.MeshBasicMaterial({map:texture2});
			var bigMesh = new THREE.Mesh(bigTop,material3);
			//bigMesh.position.x = 250;
			bigMesh.position.y += 400;
			//bigMesh.position.z = -70;
			bigMesh.rotateX(Math.PI/2);
			castle.add(bigMesh);

			//top cone
			var bigCone = new THREE.ConeGeometry( 50, 60, 80 );
			material3 = new THREE.MeshBasicMaterial({map:texture2})
			var coneMesh = new THREE.Mesh( bigCone, material3 );
			//cone5.position.x = 250;
			coneMesh.position.y += 520;
			//cone5.position.z = -70;
			castle.add( coneMesh );  
			
			return castle
			}}
	  
	  
    var Wheel = function(){
    THREE.Group.apply(this, arguments);

    var top = 150;
    var width=15;
    var segments = 15;

    var geometry = new THREE.TorusGeometry( top, width, 5, segments );
    var material = new THREE.MeshStandardMaterial( { 
        color: 0xff0051,
        shading: THREE.FlatShading, 
        metalness: 0,
        roughness: 0.4,
        refractionRatio: 0.25,
        emissive: 0xffd423,
        emissiveIntensity: 0.4 
    });
    var torus = new THREE.Mesh( geometry, material );
    torus.position.z = -200;
    torus.position.y=180;
    torus.position.x=0; 
    torus.receiveShadow = true;
    torus.castShadow = true;
    this.add(torus);

    var pointLight = new THREE.DirectionalLight( 0xffd423,.4);
    pointLight.position.set( 10, 20, 0);
    this.add( pointLight );

    var cz = torus.position.z + 30;

    var cartPositions = [
        [-15, 310, cz],
        [45, 302, cz],
        [90, 274, cz],
        [130, 238, cz],
        [140, 180, cz],
        [130, 122, cz],
        [90, 66, cz],
        [45, 38, cz],
        [-15, 30, cz],
        [-65, 292, cz],
        [-110, 264, cz],
        [-140, 200, cz],
        [-135, 137, cz],
        [-110, 91, cz],
        [-65, 50, cz]
    ];

    this.carts = [];

    for (var d =0; d<cartPositions.length; d++){
        var cart = new Cart();
        cart.position.set(cartPositions[d][0], cartPositions[d][1], cartPositions[d][2]);
        this.add(cart);
        this.carts.push(cart);
    }

    var geometry = new THREE.RingGeometry( 10, 50, 15,1 );
    var material = new THREE.MeshBasicMaterial( { color: 0xFFCCCC,
                         wireframe: true, side: THREE.DoubleSide } );
    var structure = new THREE.Mesh( geometry, material );
    structure.scale.set(3,3,3);
    structure.position.z = -215;
    structure.position.y = 180;
    structure.receiveShadow = true;
    structure.castShadow = true;
    this.add(structure);

}

Wheel.prototype = Object.create(THREE.Group.prototype);
Wheel.prototype.constructor = Wheel;
Wheel.prototype.updatePosition = function() {
    //this.rotation.z += 0.01;
    for(var d = 0; d < this.carts.length; d++) {
        this.carts[d].updatePosition();
    }
};


var Cart = function(){
    THREE.Group.apply(this, arguments);

    var geometry1 = new THREE.CylinderGeometry(10, 12, 10, 6, 1);
    var material1 = new THREE.MeshStandardMaterial({
        color: 0xf8db08,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
    });
    var shapeOne = new THREE.Mesh(geometry1, material1);
    shapeOne.position.y += 8;
    shapeOne.castShadow = true;
    shapeOne.receiveShadow = true;
    this.add(shapeOne);

    // A Torus to represent the top hook
    var geometry2 = new THREE.TorusGeometry(7,1,6,4,Math.PI);
    var material2 = new THREE.MeshStandardMaterial({
        color: 0xf8db08,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
    });
    var shapeTwo = new THREE.Mesh(geometry2,material2);
    shapeTwo.position.y += 13;
    shapeTwo.castShadow = true;
    shapeTwo.receiveShadow = true;
    this.add(shapeTwo);

    this.scale.set(1.5,1.5,1.5);
} 
Cart.prototype = Object.create(THREE.Group.prototype);
Cart.prototype.constructor = Cart;
Cart.prototype.updatePosition = function() {
    this.rotation.z -= 0.008;
};


var Iron= function(){
THREE.Group.apply(this, arguments);
var geometry = new THREE.BoxGeometry( 10, 180, 15 );
var material = new THREE.MeshLambertMaterial( {color: 0xFFC2C2} );
var cube = new THREE.Mesh( geometry, material );

cube.rotateZ(-0.40);
cube.position.z=-225;
cube.position.x=-40;
cube.position.y=80;
cube.receiveShadow= true;
cube.castShadow = true;
this.add(cube);

var geometry = new THREE.BoxGeometry( 10, 180, 15 );
var material = new THREE.MeshLambertMaterial( {color: 0xFFC2C2} );
var cube = new THREE.Mesh( geometry, material );

cube.receiveShadow= true;
cube.castShadow= true;
cube.rotateZ(0.40);
cube.position.z=-225;
cube.position.x=40;
cube.position.y=80;
this.add(cube);

var theta = 0.1;
var radius =30;
var pts=[];

var extrudeSettings = {
    steps: 1,
    amount: 18,
    bevelEnabled: true,
    bevelThickness: 1,
    bevelSize: 1,
    bevelSegments: 1};

for(var i =0; i< 70; i++){
    theta+=0.1;
    pts.push( new THREE.Vector2 ( radius * Math.cos( theta ), radius * Math.sin( theta)  ) );
}

var shape = new THREE.Shape( pts );
var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
var texture = new THREE.TextureLoader().load( 'textures/mickey.png' );

texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set( 0.04, 0.04 );

var material2 = new THREE.MeshBasicMaterial( { map: texture, wireframe: false } );

var mickeyposition=[
    [0,180,-220,1,1,1],
    [30,215,-220,0.7,0.7,1],
    [-30,215,-220,0.7,0.7,1]
];

for(var i=0; i<mickeyposition.length; i++){
var mesh = new THREE.Mesh( geometry, material2 );
mesh.position.set(mickeyposition[i][0],mickeyposition[i][1],mickeyposition[i][2]);
mesh.scale.set(mickeyposition[i][3],mickeyposition[i][4],mickeyposition[i][5]);
this.add(mesh);
}

};
Iron.prototype = Object.create(THREE.Group.prototype);
Iron.prototype.constructor = Iron;

var Carousel = function(){
THREE.Group.apply(this, arguments);

//center of it 
var geometry = new THREE.CylinderBufferGeometry(17, 17, 230, 20, 20, false);
var material = new THREE.MeshStandardMaterial({
        color: 0xffdbff,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
});

var cent = new THREE.Mesh(geometry, material);
cent.position.x+=400;
cent.position.y+=100;
cent.position.z+=100;
cent.receiveShadow=true;
cent.castShadow=true;
this.add(cent);

//base
var geometry = new THREE.CylinderBufferGeometry(140, 150, 30, 20, 20, false);
var material = new THREE.MeshStandardMaterial({
        color: 0xffdbff,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
});

var base = new THREE.Mesh(geometry, material);
base.position.y+=10;
base.position.x+=400;
base.position.z+=100;
base.rotateY(Math.PI /2);
base.receiveShadow=true;
base.castShadow=true;
this.add(base);

//top
var geometry = new THREE.ConeBufferGeometry(130, 85, 150, 1, true );
//var texture = new THREE.TextureLoader().load( 'textures/circc.jpg' );
var material = new THREE.MeshStandardMaterial( {
    map:THREE.ImageUtils.loadTexture('textures/circc.jpg'),
    side:THREE.DoubleSide,
    shading: THREE.FlatShading,
    metalness: 0,
    roughness: 0.8,
    refractionRatio: 0.25
});

var cone = new THREE.Mesh( geometry, material );
cone.position.y+=200;
cone.position.x+=400;
cone.position.z+=100;
cone.receiveShadow=true;
cone.castShadow=true;
this.add( cone );

    var loader = new THREE.JSONLoader( true );
    loader.load( "buildingTexture/horse.js", createhorse); 

  var group = new THREE.Group();

    function createhorse( geometry ) {
    material = new THREE.MeshLambertMaterial( { color: 0xbb8144
    , morphTargets: true } );
    
    var horsesPosition =[
        [315,30,90,0,0],
        [375,30,195,0,0.7],
        [470, 30,165,0,2],
        [395,30,10,0,-0.6],
        [495,30,45,0,3.5]
    ];
  
    for(var h=0; h<horsesPosition.length; h++){
    horse = new THREE.Mesh( geometry, material );
    horse.scale.set( 0.48, 0.48, 0.28 );
    horse.receiveShadow=true;
    horse.castShadow=true;
    horse.position.set(horsesPosition[h][0],horsesPosition[h][1],horsesPosition[h][2]);
    horse.rotateX(horsesPosition[h][3]);
    horse.rotateY(horsesPosition[h][4]);
    group.add(horse);
            }
    }
this.add(group);
this.scale.set(0.85,0.85,0.85);
}
Carousel.prototype = Object.create(THREE.Group.prototype);
Carousel.prototype.constructor = Carousel;

var Teapot = function(){
    THREE.Group.apply(this,arguments);
//teapot
    var geometry = new THREE.SphereBufferGeometry( 40,160,160);
    var material = new THREE.MeshStandardMaterial( {color: 0xff9966,
    side: THREE.DoubleSide,
    shading: THREE.FlatShading,
    metalness: 0,
    roughness: 0.8,
    refractionRatio: 0.25} );
    
    var sphere = new THREE.Mesh( geometry, material );
    sphere.receiveShadow=true;
    sphere.castShadow=true;
    this.add( sphere );  
    sphere.position.set(-340,65,100);
    sphere.scale.set(1,1.1,1.1);

    //dot on top
    var geometry = new THREE.SphereBufferGeometry( 5,160,160);
    var material = new THREE.MeshStandardMaterial( {color: 0x660033,
    side: THREE.DoubleSide,
    shading: THREE.FlatShading,
    metalness: 0,
    roughness: 0.8,
    refractionRatio: 0.25} );

    var dot = new THREE.Mesh( geometry, material );
    dot.receiveShadow=true;
    dot.castShadow=true;
    this.add(dot );  
    dot.position.set(-340,112,100);
    dot.scale.set(1.4,1.0,1.0);


    //lining
    var geometry = new THREE.CircleBufferGeometry( 29, 32 );
    var material = new THREE.MeshLambertMaterial( { color: 0x660033,
    side: THREE.DoubleSide,
    metalness: 0,
    roughness: 0.8,
    refractionRatio: 0.25 } );
    var circle = new THREE.Mesh( geometry, material );
    circle.rotateX(Math.PI /2);
    circle.position.set(-340,100,100);
    this.add( circle );
//the pouring handle
    var geometry = new THREE.TorusBufferGeometry( 25, 8, 100, 100 , Math.PI /2);
    var material = new THREE.MeshStandardMaterial( { color: 0xff9966 , side:THREE.DoubleSide,    shading: THREE.FlatShading,
    metalness: 0,
    roughness: 0.8,
    refractionRatio: 0.25 } );

    var torus = new THREE.Mesh( geometry, material );
        torus.position.set(-365,80,100);
        this.add(torus);
        torus.rotateX(Math.PI );
        torus.rotateY(Math.PI);
//handle
    var geometry2 = new THREE.TorusBufferGeometry(24,5,20,40,Math.PI);
    var material2 = new THREE.MeshStandardMaterial({
        color: 0xff9966,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
    });
    var handle = new THREE.Mesh(geometry2,material2);
    handle.position.set(-310,65,100);
    handle.castShadow = true;
    handle.receiveShadow = true;
    handle.rotateZ(- (Math.PI/2));
    this.add(handle);

    //base
    var geometry = new THREE.CylinderBufferGeometry(130, 130, 20, 20, 20, false);
    var material = new THREE.MeshStandardMaterial({
            color: 0xffdbff,
            shading: THREE.FlatShading ,
            metalness: 0,
            roughness: 0.8,
            refractionRatio: 0.25
    });

    var base = new THREE.Mesh(geometry, material);
    base.position.y+=8.5;
    base.position.x-=340;
    base.position.z+=85;
    base.rotateY(Math.PI /2);
    base.receiveShadow=true;
    base.castShadow=true;
    this.add(base);


var cupsPosition =[
    [-435,47,110],
    [-325,47,185],
    [-240,47,115],
    [-280,47,20],
    [-390,47,25]
];
this.cups = [];
for(var c=0; c<cupsPosition.length; c++){
    var cup = new Cups();
    cup.position.set(cupsPosition[c][0], cupsPosition[c][1], cupsPosition[c][2]);
    this.add(cup);
    this.cups.push(cup);    
    }

}
Teapot.prototype = Object.create(THREE.Group.prototype);
Teapot.prototype.constructor = Teapot;
Teapot.prototype.updatePosition = function(){
    for(var d = 0; d < this.cups.length; d++) {
        this.cups[d].updatePosition();
    }
}

var Cups = function(){
THREE.Group.apply(this, arguments);

var colors = ['#ff0051', '#f56762','#53c6c','#f19fa0','#72bdbf','#47689b', '#ff66cc','#ff9900','#ff99ff', '#00ffcc', '#ffffb3', '#990099','#b380ff','#ccff33', '#FFFF00', '#ffff66'];

var geometry = new THREE.SphereBufferGeometry( 40, 12, 12,0, Math.PI*2,0, (Math.PI/2)+0.4);

var rand = Math.floor(Math.random()*colors.length);
var material = new THREE.MeshStandardMaterial( {color: colors[rand],
    side: THREE.DoubleSide,
    shading: THREE.FlatShading,
    metalness: 0,
    roughness: 0.8,
    refractionRatio: 0.25} );
var sphere = new THREE.Mesh( geometry, material );
sphere.rotateX(Math.PI);
sphere.receiveShadow=true;
sphere.castShadow=true;

this.add( sphere );

var geometry2 = new THREE.TorusBufferGeometry(15,3,10,40,Math.PI);
var material2 = new THREE.MeshStandardMaterial({
        color: colors[rand],
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
});
var handle = new THREE.Mesh(geometry2,material2);
handle.position.x-= 32;
handle.position.y= -5;

handle.castShadow = true;
handle.receiveShadow = true;
handle.rotateZ(Math.PI/2);
this.add(handle);

this.castShadow = true;
this.receiveShadow = true;
this.scale.set(0.7,0.7,0.7);

}
Cups.prototype = Object.create(THREE.Group.prototype);
Cups.prototype.constructor = Cups;
Cups.prototype.updatePosition = function() {
    this.rotation.y -= 0.018;
};


var wheel = new Wheel(); //with the carts
var iron = new Iron(); 
var teapot = new Teapot(); //with the cups
var carousel = new Carousel(); // with the horses

scene.add(iron);

var teapivot = new THREE.Object3D();
teapivot.position.set(-340,65,100);
scene.add(teapivot);
teapot.position.set(340,-65,-100);
teapivot.add(teapot);

var caropivot = new THREE.Object3D();
caropivot.position.x = 340;
caropivot.position.z = 85;
caropivot.position.y= -85;
scene.add(caropivot);
carousel.position.x=-340;
carousel.position.z=-85;
carousel.position.y=85;
caropivot.add(carousel);


var wheelpivot = new THREE.Object3D();
wheelpivot.position.z= 200;
wheelpivot.position.y=180;
scene.add(wheelpivot);
wheel.position.y-=180;
wheel.position.z-=200;
wheelpivot.add(wheel);

var grass = new THREE.TextureLoader().load( "textures/grass2.jpg" );
var grassMaterial = new THREE. MeshStandardMaterial( { map: grass } );
var groundMesh = new THREE.Mesh(
    new THREE.BoxGeometry( 1500, .1, 1500 ),
   grassMaterial
);
groundMesh.receiveShadow = true;
//groundMesh.position.set(0,-10,0);
scene.add( groundMesh );

animate();
renderer.render(scene, camera);

function animate() {
    wheel.updatePosition();
    teapot.updatePosition();
    caropivot.rotation.y+=0.007;
    wheelpivot.rotation.z+=0.008;
    teapivot.rotation.y+=0.007;
    
    requestAnimationFrame(animate);
    camera.updateProjectionMatrix();
    render();
}

function render() {
    camera.lookAt(scene.position);
    renderer.render(scene, camera);
}

function onWindowResize () {
      window.addEventListener('resize', function () {
        width = window.innerWidth
        height = window.innerHeight

        camera.aspect = width / height;
        camera.updateProjectionMatrix()

        renderer.setSize(width, height)
		
      })
  }
    
  </script>
</body>
</html>