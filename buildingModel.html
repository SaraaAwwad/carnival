<!DOCTYPE html>
<html>
<head>
  <title>Building</title>
   <link rel="icon" href="buildingTexture/MIU-Logo-20th.png">
     <script src="buildingTexture/three.min.js"></script>
     <script src="buildingTexture/functions.js"></script>
     <script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
     <script type="text/javascript" src="three.js-master/examples/js/controls/TrackballControls.js"></script>
     <link href="https://fonts.googleapis.com/css?family=Crafty+Girls" rel="stylesheet">
  <style>
    h3{
      display: block;
      font-size: 50px;
      line-height: 28px;
      color: #082236;
      text-decoration: none;
	  z-index: 10;
	  position: absolute;
      margin: 50px 5px;
      position: absolute;
      text-align: center;
      opacity: 0.5;
      width:100%;
      font-family: 'Crafty Girls', cursive;
	  }
  </style>
</head>
<body>
  <div>
    <h3> Building Model</h3>
  </div>

  <script>
    var scene, camera, renderer, width, height, controls
    var color = { background: 0xA9D5F6 }
    width = window.innerWidth
    height = window.innerHeight
	
	
    scene = new THREE.Scene()
    camera = new THREE.PerspectiveCamera(45, width / height, 1, 5000);
    camera.position.x = 330;
    camera.position.y = 330;
	camera.position.z = 330;
    camera.lookAt({
        x: 0,
        y: 0,
        z: 0
    });
	scene.add(camera)
	
	renderer = new THREE.WebGLRenderer()
    renderer.setSize(width, height)
    renderer.setClearColor(color.background)
	renderer.domElement.style.position = "relative";
    renderer.shadowMap.enabled = true
	renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    document.body.appendChild(renderer.domElement)


    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.target = new THREE.Vector3(300,100,-10);
    controls.maxPolarAngle = Math.PI / 2;


	//animate()
	//rotate()
	addTrees()
    Light()
    building()
    //loop()
    onWindowResize()
    
    function building () {
      var planeGeometry = new THREE.BoxBufferGeometry(350,6,350)
      var plane = utils.makeMesh('lambert', planeGeometry, 0x6f5f6a)
      plane.position.y = -2
      scene.add(plane)

      addBuilding()

      function addBuilding () {
        var building = createBuilding()
        building.position.z = -3
        scene.add(building)  
      }
	  

      function createBuilding () {
        var building = new THREE.Object3D()

		//Base
        var baseGeometry = new THREE.BoxBufferGeometry(100, 3, 100)
        var base = utils.makeMesh('lambert', baseGeometry, 0x838383)
        base.position.y = 1
        building.add(base)

		//Main Building Shape
        var MainCoords = [
          [-60, -30], [-60, 20], [60, 20], [60, 0], [60, -30], [60, -30]
        ]
		//Main Building Creation
        var MainShape = utils.makeShape(MainCoords)
        var Geometry = utils.makeExtrudeGeometry(MainShape,100)
        var Material = new THREE.MeshPhongMaterial({color: 0x796e8c,
        opacity: 0.9,
        transparent: true})
        var Main = new THREE.Mesh(Geometry, Material)
        Main.castShadow = true
        Main.receiveShadow = true
        building.add(Main)

		//Main Roof Base
        var MainTop = MainShape
        var Geometry = utils.makeExtrudeGeometry(MainTop, 1)
        var Material = utils.makeMesh('lambert', Geometry, 0x9F9378)
        Material.position.y = 100
        building.add(Material)
        
        //Main Building Plat
        var Geometry = new THREE.BoxBufferGeometry(155,3,90)
        var Plat = utils.makeMesh('lambert', Geometry, 0x9F9378)
        Plat.position.set(1,18,25)
        building.add(Plat)

		//Vertical Plat
        var Geometry = new THREE.BoxBufferGeometry(100, 15, 3)
        var Vertical = utils.makeMesh('phong', Geometry, 0x9F9378)
        Vertical.receiveShadow = false
        Vertical.position.set(-26.5, 24, 68.5)
        building.add(Vertical)

		//Vertical White Plat
        var Geometry = new THREE.BoxBufferGeometry(100, 3, 3)
        var Material = utils.makeMesh('phong', Geometry, 0xffffff)
        Material.position.set(-26.5, 33, 68.5)
        building.add(Material)

		//First Front Pillar
        var Geometry = new THREE.CylinderGeometry(2, 2, 15, 32)
        var Pillar = utils.makeMesh('lambert', Geometry, 0xffffff)
        Pillar.position.set(-40, 10, 55)
        building.add(Pillar)

		//Second Front Pillar
        var Pillar2 = Pillar.clone()
        Pillar2.position.set(40, 10, 55)
        building.add(Pillar2)

		//Long 8 Pillars
        var Verticles = new THREE.Object3D()
        var Geometry = new THREE.BoxBufferGeometry(4, 102, 4)
        var Mesh = utils.makeMesh('phong', Geometry, 0xffffff)
        
		var Verticle1 = Mesh.clone()
        Verticle1.position.set(-60, 52, 30)
        Verticles.add(Verticle1)
		
        var Verticle2 = Mesh.clone()
        Verticle2.position.set(-60, 52, -20)
        Verticles.add(Verticle2)

		var Verticle3 = Mesh.clone()
        Verticle3.position.set(60, 52, -18)
        Verticles.add(Verticle3)
		
		var Verticle4 = Mesh.clone()
        Verticle4.position.set(60, 52, 30)
        Verticles.add(Verticle4)
		
		var Verticle5 = Mesh.clone()
        Verticle5.position.set(80, 52, -21)
        Verticles.add(Verticle5)
		
		var Verticle6 = Mesh.clone()
        Verticle6.position.set(-80, 52, -59.5)
        Verticles.add(Verticle6)
		
		var Verticle7 = Mesh.clone()
        Verticle7.position.set(80, 52, -59.5)
        Verticles.add(Verticle7)
		
		var Verticle8 = Mesh.clone()
        Verticle8.position.set(-80, 52, -18)
        Verticles.add(Verticle8)
		building.add(Verticles)
		
        var Coords = [
          [-80, 20], [-80, 60], [80, 60], [80, 20], [-80, 20]
        ]
        
        var Main = utils.makeShape(Coords)
		var Geometry = utils.makeExtrudeGeometry(Main, 90)        
		var backMain = utils.makeMesh('lambert', Geometry, 0x9F9378)
        building.add(backMain)

		//Back Main Roof Base
        var Top1 = Main
        var Geometry = utils.makeExtrudeGeometry(Top1, 1)
        var Mesh = utils.makeMesh('lambert', Geometry, 0x9F9378)
		
        Mesh.position.x = 0
		Mesh.position.y = 100
        Mesh.position.z = 0
       
        building.add(Mesh)
		
		var Top2 = Main
        var frontTopGeometry = utils.makeExtrudeGeometry(Top2, 1)
        var Mesh = utils.makeMesh('lambert', Geometry, 0xffffff)
        Mesh.position.x = 0
		Mesh.position.y = 90
        Mesh.position.z = 0
       
        building.add(Mesh)

		//Sideways
		var Geometry = new THREE.BoxBufferGeometry(50, 3, 168)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = 0
		Mesh.position.y = 1
        Mesh.position.z = 80
        Mesh.rotation.y = 1 * Math.PI
        building.add(Mesh)
		
		var Geometry = new THREE.BoxBufferGeometry(20, 3, 310)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = -150
		Mesh.position.y = 1
        Mesh.position.z = 5
        Mesh.rotation.y = 1 * Math.PI
        building.add(Mesh)
	
	    var Geometry = new THREE.BoxBufferGeometry(20, 3, 310)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = -5
		Mesh.position.y = 1
        Mesh.position.z = -145
        Mesh.rotation.y = 1.5 * Math.PI
        building.add(Mesh)
		
		var Geometry = new THREE.BoxBufferGeometry(20, 3, 320)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = 150
		Mesh.position.y = 1
        Mesh.position.z = 5
        Mesh.rotation.y = 1 * Math.PI
        building.add(Mesh)
		
		var Geometry = new THREE.BoxBufferGeometry(20, 3, 310)
		var Mesh = utils.makeMesh('lambert', Geometry, 0x838383)
        Mesh.position.x = -5
		Mesh.position.y = 1
        Mesh.position.z = 155
        Mesh.rotation.y = 1.5 * Math.PI
        building.add(Mesh)
		
		
	    //Side Window
        var Geometry = new THREE.PlaneGeometry(30,70,1,1)
        var Material = new THREE.MeshPhongMaterial({color: 0x796e8c,
        opacity: 0.8,
        transparent: true})
		
        var Window = new THREE.Mesh(Geometry, Material)
        Window.position.set(81, 46, -40.5)
        Window.rotation.y = 0.5 * Math.PI
        building.add(Window)
		
		//Side Window 2
        var Geometry = new THREE.PlaneGeometry(32,76,1,1)
        var Material = new THREE.MeshPhongMaterial({color: 0x796e8c,
        opacity: 0.8,
        transparent: true})

        var Window2 = new THREE.Mesh(Geometry, Material)
        Window2.position.set(-81, 46, -40)
        Window2.rotation.y = 1.5 * Math.PI
        building.add(Window2)
		
	
        var Back = addWindow()
        Back.scale.set(1.5,1.5,1)
        Back.rotation.y = Math.PI
        Back.position.set(40, 68, -61)
        for (var i = 0; i < 2; i++) {
          for (var j = 0; j < 2; j++) {
            var window = Back.clone()
            window.position.x -= i * 70
            window.position.y -= j * 45
            building.add(window)
          }
        }
        return building
      }

      function addWindow () {
        var window = new THREE.Object3D()
        var Geometry = new THREE.PlaneGeometry(20, 20)
        var glass = utils.makeMesh2('phong', Geometry, 0x796e8c)
        window.add(glass)

        var BorderGeometry = new THREE.BoxBufferGeometry(20.5,0.5,0.5)
        var Border = utils.makeMesh('phong', BorderGeometry, 0xffffff)

        var Top = Border.clone()
        Top.position.y = 10
        window.add(Top)

        var Bottom = Border.clone()
        Bottom.position.y = -10
        window.add(Bottom)

        var Left = Border.clone()
        Left.rotation.z = 0.5 * Math.PI
        Left.position.x = -10
        window.add(Left)

        var Right = Left.clone()
        Right.position.x = 10
        window.add(Right)

        return window
      }
    }
    
    function Light() {
      
	    var direction = 400;
        var directional = new THREE.DirectionalLight( 0xffffff , 1.1);
        directional.position.set( 300, 1000, 500 );
        directional.target.position.set( 0, 0, 0 );
        directional.castShadow = true;
        directional.shadow.camera = new THREE.OrthographicCamera( -direction, direction, direction, -direction,  500, 1600 );
        directional.shadow.bias = 0.0001;
        directional.shadow.mapSize.width = directional.shadow.mapSize.height = 1024;
        scene.add(directional)
        var light = new THREE.AmbientLight( 0xffffff, 0.4 )
        scene.add(light)

    }
	
	function addTrees () {
        var Position = [ [-110, -110],[-110,  0],[110,  0],[ 110,  -110], [110, 110],  [30, 110], [-30, 110],  [-110, 110] ]
        Position.forEach(function (t) {
          var x = t[0], y = 1, z = t[1]
          var tree = addTree(x, y, z)
          scene.add(tree)
        })
    }
	function addTree (x, y, z) {	
        var tree = new THREE.Object3D()
        var TrunkGeometry = new THREE.BoxBufferGeometry(3,25,2)
        var Trunk = utils.makeMesh('lambert', TrunkGeometry, 0x8a613a)
        Trunk.position.y = 8
        tree.add(Trunk)
        var Geometry = new THREE.SphereGeometry(10, 20,10)
        var Leafs = utils.makeMesh('lambert', Geometry, 0x9c9e5d)
        Leafs.position.y = 20
        tree.add( Leafs)
        tree.position.set(x, y, z)
        return tree
      }

      var Wheel = function(){
    THREE.Group.apply(this, arguments);

    var top = 150;
    var width=15;
    var segments = 15;

    var geometry = new THREE.TorusGeometry( top, width, 5, segments );
    var material = new THREE.MeshStandardMaterial( { 
        color: 0xff0051,
        shading: THREE.FlatShading, 
        metalness: 0,
        roughness: 0.4,
        refractionRatio: 0.25,
        emissive: 0xffd423,
        emissiveIntensity: 0.4 
    });
    var torus = new THREE.Mesh( geometry, material );
    torus.position.z = -200;
    torus.position.y=140;
    torus.position.x=0; 
    torus.receiveShadow = true;
    torus.castShadow = true;
    this.add(torus);

    var pointLight = new THREE.DirectionalLight( 0xffd423,.4);
    pointLight.position.set( 10, 20, 0);
    this.add( pointLight );

    var cz = torus.position.z + 30;

    var cytop = top-20;
    var cybottom = -(top-20);
    var cxright = top-20;
    var cxleft = -(top-20);
    var postx = 45;
    var yconst = 18;

    var cartPositions = [
        [-15, cytop+140, cz],
        [postx, cytop-yconst+10+140, cz],
        [(postx*2), cytop-(yconst*2)+140, cz],
        [cxright, cytop-(yconst*4)+140, cz],
        [140, 140, cz],
        [cxright, cybottom+(yconst*4)+140, cz],
        [postx*2, cybottom+(yconst*2)-20+140, cz],
        [postx, cybottom+(yconst)-30+140, cz],
        [-15, -150+140, cz],

        [-65, cytop-(yconst)+140, cz],
        [-110, cytop-(yconst*2)-10+140, cz],
        [-140, 20+140, cz],
        [-cxright-5, cybottom+(yconst*4)+15+140, cz],
        [-110, cybottom+(yconst*2)+5+140, cz],
        [-65, cybottom+140, cz]
    ];

    this.carts = [];

    for (var d =0; d<cartPositions.length; d++){
        var cart = new Cart();
        cart.position.set(cartPositions[d][0], cartPositions[d][1], cartPositions[d][2]);
      // cart.rotateX(decorationPositions[d][3]);
      // cart.rotateZ(decorationPositions[d][4]);
        this.add(cart);
        this.carts.push(cart);
    }

    var geometry = new THREE.RingGeometry( 10, 50, 15,1 );
    var material = new THREE.MeshBasicMaterial( { color: 0xFFCCCC,
                         wireframe: true, side: THREE.DoubleSide } );
    var structure = new THREE.Mesh( geometry, material );
    structure.scale.set(3,3,3);
    structure.position.z = -215;
    structure.position.y = 140;
    structure.receiveShadow = true;
    structure.castShadow = true;
    this.add(structure);

}

Wheel.prototype = Object.create(THREE.Group.prototype);
Wheel.prototype.constructor = Wheel;
Wheel.prototype.updatePosition = function() {
    //this.rotation.z += 0.01;
    for(var d = 0; d < this.carts.length; d++) {
        this.carts[d].updatePosition();
    }
};


var Cart = function(){
    THREE.Group.apply(this, arguments);

    var geometry1 = new THREE.CylinderGeometry(10, 12, 10, 6, 1);
    var material1 = new THREE.MeshStandardMaterial({
        color: 0xf8db08,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
    });
    var shapeOne = new THREE.Mesh(geometry1, material1);
    shapeOne.position.y += 8;
    shapeOne.castShadow = true;
    shapeOne.receiveShadow = true;
    this.add(shapeOne);

    // A Torus to represent the top hook
    var geometry2 = new THREE.TorusGeometry(7,1,6,4,Math.PI);
    var material2 = new THREE.MeshStandardMaterial({
        color: 0xf8db08,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
    });
    var shapeTwo = new THREE.Mesh(geometry2,material2);
    shapeTwo.position.y += 13;
    shapeTwo.castShadow = true;
    shapeTwo.receiveShadow = true;
    this.add(shapeTwo);

    this.scale.set(1.5,1.5,1.5);
} 
Cart.prototype = Object.create(THREE.Group.prototype);
Cart.prototype.constructor = Cart;
Cart.prototype.updatePosition = function() {
    this.rotation.z -= 0.01;
};


var Iron= function(){
THREE.Group.apply(this, arguments);
var geometry = new THREE.BoxGeometry( 10, 160, 15 );
var material = new THREE.MeshLambertMaterial( {color: 0xFFC2C2} );
var cube = new THREE.Mesh( geometry, material );

cube.rotateZ(-0.40);
cube.position.z=-225;
cube.position.x=-40;
cube.position.y=80;
cube.receiveShadow= true;
cube.castShadow = true;
this.add(cube);

var geometry = new THREE.BoxGeometry( 10, 160, 15 );
var material = new THREE.MeshLambertMaterial( {color: 0xFFC2C2} );
var cube = new THREE.Mesh( geometry, material );

cube.receiveShadow= true;
cube.castShadow= true;
cube.rotateZ(0.40);
cube.position.z=-225;
cube.position.x=40;
cube.position.y=80;
this.add(cube);

var theta = 0.1;
var radius =30;
var pts=[];

var extrudeSettings = {
    steps: 1,
    amount: 18,
    bevelEnabled: true,
    bevelThickness: 1,
    bevelSize: 1,
    bevelSegments: 1};

for(var i =0; i< 70; i++){
    theta+=0.1;
    pts.push( new THREE.Vector2 ( radius * Math.cos( theta ), radius * Math.sin( theta)  ) );
}

var shape = new THREE.Shape( pts );
var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
var texture = new THREE.TextureLoader().load( 'textures/mickey.png' );

texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set( 0.04, 0.04 );

var material2 = new THREE.MeshBasicMaterial( { map: texture, wireframe: false } );
var mesh = new THREE.Mesh( geometry, material2 );
//mesh.scale.set(5,5,5);
mesh.position.z-=220;
mesh.position.y+=140;
this.add(mesh);

};
Iron.prototype = Object.create(THREE.Group.prototype);
Iron.prototype.constructor = Iron;

var Carousel = function(){
THREE.Group.apply(this, arguments);

//center of it 
var geometry = new THREE.CylinderBufferGeometry(17, 17, 230, 20, 20, false);
var material = new THREE.MeshStandardMaterial({
        color: 0xffdbff,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
});

var cent = new THREE.Mesh(geometry, material);
cent.position.x+=400;
cent.position.y+=100;
cent.position.z+=100;
cent.receiveShadow=true;
cent.castShadow=true;
this.add(cent);

//base
var geometry = new THREE.CylinderBufferGeometry(140, 150, 30, 20, 20, false);
var material = new THREE.MeshStandardMaterial({
        color: 0xffdbff,
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
});

var base = new THREE.Mesh(geometry, material);
base.position.y+=10;
base.position.x+=400;
base.position.z+=100;
base.rotateY(Math.PI /2);
base.receiveShadow=true;
base.castShadow=true;
this.add(base);

//top
var geometry = new THREE.ConeBufferGeometry(160, 65, 8, 1, true );
var texture = new THREE.TextureLoader().load( 'textures/col.jpg' );
var material = new THREE.MeshStandardMaterial( {
    
    map:texture,
    side:THREE.DoubleSide,
    shading: THREE.FlatShading,
    metalness: 0,
    roughness: 0.8,
    refractionRatio: 0.25
});

var cone = new THREE.Mesh( geometry, material );
cone.position.y+=200;
cone.position.x+=400;
cone.position.z+=100;
cone.receiveShadow=true;
cone.castShadow=true;
this.add( cone );

var cupsPosition =[
    [315,65,110],
    [375,65,195],
    [470, 65,125],
    [345,65,25],
    [455,65,40]
];
this.cups = [];
for(var c=0; c<cupsPosition.length; c++){
    var cup = new Cups();
    cup.position.set(cupsPosition[c][0], cupsPosition[c][1], cupsPosition[c][2]);
    this.add(cup);
    this.cups.push(cup);    
    }

}
Carousel.prototype = Object.create(THREE.Group.prototype);
Carousel.prototype.constructor = Carousel;
Carousel.prototype.updatePosition = function(){

}

var Cups = function(){
THREE.Group.apply(this, arguments);

    var colors = ['#ff0051', '#f56762','#53c6c','#f19fa0','#72bdbf','#47689b'];

var geometry = new THREE.SphereBufferGeometry( 40, 12, 12,0, Math.PI*2,0, (Math.PI/2)+0.4);

var rand = Math.floor(Math.random()*colors.length);
var material = new THREE.MeshStandardMaterial( {color: colors[rand],
    side: THREE.DoubleSide,
    shading: THREE.FlatShading,
    metalness: 0,
    roughness: 0.8,
    refractionRatio: 0.25} );
var sphere = new THREE.Mesh( geometry, material );
sphere.rotateX(Math.PI);
sphere.receiveShadow=true;
sphere.castShadow=true;

this.add( sphere );

var geometry2 = new THREE.TorusBufferGeometry(15,3,10,40,Math.PI);
var material2 = new THREE.MeshStandardMaterial({
        color: colors[rand],
        shading: THREE.FlatShading ,
        metalness: 0,
        roughness: 0.8,
        refractionRatio: 0.25
});
var handle = new THREE.Mesh(geometry2,material2);
handle.position.x-= 35;
handle.position.y= 0;

handle.castShadow = true;
handle.receiveShadow = true;
handle.rotateZ(Math.PI/2);
this.add(handle);

}
Cups.prototype = Object.create(THREE.Group.prototype);
Cups.prototype.constructor = Cups;

var wheel = new Wheel();
var iron = new Iron();
scene.add(iron);
var carousel = new Carousel();

var dummy = new THREE.Object3D();
dummy.position.x = 400;
dummy.position.z = 100;
dummy.position.y= -100
scene.add(dummy);
carousel.position.x=-400;
carousel.position.z=-100;
carousel.position.y=100;
dummy.add(carousel);


var dummy2 = new THREE.Object3D();
dummy2.position.z= 200;
dummy2.position.y=140;
scene.add(dummy2);
wheel.position.y-=140;
wheel.position.z-=200;
dummy2.add(wheel);

	
animate();
renderer.render(scene, camera);

function animate() {
    wheel.updatePosition();
    dummy.rotation.y-=0.01;
    dummy2.rotation.z+=0.01;

    requestAnimationFrame(animate);
    render();
}

function render() {
    camera.lookAt(scene.position);
    renderer.render(scene, camera);
}

function onWindowResize () {
      window.addEventListener('resize', function () {
        width = window.innerWidth
        height = window.innerHeight

        camera.aspect = width / height;
        camera.updateProjectionMatrix()

        renderer.setSize(width, height)
		
      })
    }

  </script>
</body>
</html>